import { ref, onMounted, onUnmounted } from 'vue';
import { invoke } from '@tauri-apps/api/core';
import { open } from '@tauri-apps/plugin-dialog';
import { listen } from '@tauri-apps/api/event';
import { useI18n } from 'vue-i18n';

export interface EngineLine { text: string; kind: 'sent' | 'recv' }

// function dbg(tag: string, ...m: any[]) { // console.log('[UCI]', tag, ...m) }

export function useUciEngine(generateFen: () => string) {
  const { t } = useI18n();
  const engineOutput = ref<EngineLine[]>([]);
  const isEngineLoaded = ref(false);
  const bestMove = ref('');
  const analysis = ref('');
  const isThinking = ref(false);
  const pvMoves = ref<string[]>([]);          // Real-time PV
  // MultiPV: store moves for each PV index (0-based)
  const multiPvMoves = ref<string[][]>([]);
  // Cache of analysis lines for each PV
  const analysisLines: string[] = [];
  const uciOptionsText = ref(''); // cache UCI options raw text
  const currentEnginePath = ref(''); // current engine path

  let unlisten: (() => void) | null = null;

  /* ---------- Load Engine ---------- */
  const loadEngine = async () => {
    try {
      const path = await open({ multiple: false, title: '选择UCI引擎' });
      if (typeof path === 'string' && path) {
        engineOutput.value = []; bestMove.value = ''; analysis.value = ''; pvMoves.value = [];
        currentEnginePath.value = path; // Store engine path
        await invoke('spawn_engine', { path });
        isEngineLoaded.value = true;
        send('uci');
        
        // Automatically apply saved configuration after engine loads
        setTimeout(() => {
          applySavedSettings();
        }, 500);
      }
    } catch(e) { alert('Failed to load engine'); }
  };

  /* ---------- Basic Send ---------- */
  const send = (cmd: string) => { if(!isEngineLoaded.value) return;
    engineOutput.value.push({text: cmd, kind: 'sent'}); invoke('send_to_engine', { command: cmd }) };

  /* ---------- Start Analysis ---------- */
  // New param baseFen: specifies the FEN for the starting position (before executing moves).
  // If not provided, it defaults to the FEN of the current position generated by generateFen().
  const startAnalysis = (settings: any = {}, moves: string[] = [], baseFen: string | null = null) => {
    if(!isEngineLoaded.value || isThinking.value) return;
    
    // Default settings
    const defaultSettings = {
      movetime: 1000,
      maxDepth: 20,
      maxNodes: 1000000,
      analysisMode: 'movetime'
    };
    
    const finalSettings = { ...defaultSettings, ...settings };
        
    // Use baseFen if provided, otherwise use the FEN of the current position.
    const fenToUse = baseFen ?? generateFen();
    const pos = `position fen ${fenToUse}${moves.length ? ' moves ' + moves.join(' ') : ''}`;
    isThinking.value = true; 
    bestMove.value = ''; 
    pvMoves.value = []; 
    multiPvMoves.value = []; // reset MultiPV cache
    analysisLines.length = 0; // clear cached analysis lines
    analysis.value = '思考中…';
    
    send(pos);
    
    // Send different go commands based on analysis mode
    switch (finalSettings.analysisMode) {
      case 'depth':
        send(`go depth ${finalSettings.maxDepth}`);
        break;
      case 'nodes':
        send(`go nodes ${finalSettings.maxNodes}`);
        break;
      case 'movetime':
      default:
        send(`go movetime ${finalSettings.movetime}`);
        break;
    }
  };

  /* ---------- Stop Analysis ---------- */
  const stopAnalysis = () => {
    if(!isEngineLoaded.value || !isThinking.value) return;
    
    send('stop');
    isThinking.value = false;
    analysis.value = '分析已停止';
  };



  /* ---------- Apply Saved Settings ---------- */
  const applySavedSettings = () => {
    if (!isEngineLoaded.value || !currentEnginePath.value) return;
    
    // Apply analysis settings
    const analysisSettings = localStorage.getItem('analysis-settings');
    if (analysisSettings) {
    }
    
    // Apply UCI options settings
    const enginePathHash = btoa(currentEnginePath.value).replace(/[^a-zA-Z0-9]/g, '');
    const uciOptionsKey = `uci-options-${enginePathHash}`;
    const savedUciOptions = localStorage.getItem(uciOptionsKey);
    
    if (savedUciOptions) {
      try {
        const options = JSON.parse(savedUciOptions);
        Object.entries(options).forEach(([name, value]) => {
          const command = `setoption name ${name} value ${value}`;
          send(command);
        });
      } catch (e) {
      }
    }
  };

  /* ---------- Listen to Output ---------- */
  onMounted(async() => {
    unlisten = await listen<string>('engine-output', (ev) => {
      const ln = ev.payload; engineOutput.value.push({text: ln, kind: 'recv'});

      // -------- MultiPV parsing helpers --------
      const mpvMatch = ln.match(/\bmultipv\s+(\d+)/);
      const mpvIndex = mpvMatch ? parseInt(mpvMatch[1], 10) - 1 : 0; // 0-based index

      /* --- Extract PV (using indexOf is more robust than regex) --- */
      const idx = ln.indexOf(' pv ');
      if(idx !== -1) {
        const mvStr = ln.slice(idx + 4).trim();           // 4 = ' pv '.length
        const movesArr = mvStr.split(/\s+/);
        // Update primary pvMoves for backward compatibility
        if (mpvIndex === 0) {
          pvMoves.value = movesArr;
        }
        // Store into multiPvMoves with reactive update
        if (mpvIndex >= multiPvMoves.value.length) {
          // Append
          multiPvMoves.value.push(movesArr);
        } else {
          // Replace existing index to keep order
          multiPvMoves.value.splice(mpvIndex, 1, movesArr);
        }
      }
      // ------ Aggregate analysis lines (show all PVs) ------
      if(ln.startsWith('info') && ln.includes('score')) {
        analysisLines[mpvIndex] = ln;
        // Join available lines by newline
        analysis.value = analysisLines.filter(Boolean).join('\n');
      }

      if(ln.startsWith('bestmove')) {
        const mv = ln.split(' ')[1] ?? ''; 
        
        // Check if it's a checkmate situation (none) - use trim() to remove possible spaces
        const trimmedMv = mv.trim();
        if(trimmedMv === '(none)' || trimmedMv === 'none') {
          analysis.value = t('uci.checkmate');
          send('stop');
        } else {
          analysis.value = mv ? t('uci.bestMove', { move: mv }) : t('uci.noMoves');
        }
        
        bestMove.value = mv; // Set bestMove
        
        // Stop thinking state
        isThinking.value = false; 
        pvMoves.value = [];
        multiPvMoves.value = [];
      }
      if(ln === 'uciok') send('isready');
      if(ln === 'readyok') analysis.value = t('uci.engineReady');

      // record UCI options
      if (ln.startsWith('option name ')) {
        uciOptionsText.value += ln + '\n';
      }
    });
  });
  onUnmounted(() => unlisten?.());

  return { 
    engineOutput, isEngineLoaded, bestMove, analysis, isThinking, pvMoves, multiPvMoves,
    loadEngine, startAnalysis, stopAnalysis, uciOptionsText, send, currentEnginePath, applySavedSettings 
  };
}
